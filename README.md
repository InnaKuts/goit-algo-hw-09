### 1. Жадібний алгоритм

Жадібний алгоритм спочатку бере найбільші монети, доступні для суми, що залишилася. 
Це підхід "найкраще зараз" і працює швидко для таких завдань. 
Для більшості класичних наборів монет (як у прикладі), цей алгоритм знаходить оптимальне рішення. 

### 2. Алгоритм динамічного програмування

Алгоритм динамічного програмування використовує підхід оптимізації зверху вниз. 
Він будує рішення для кожної суми від 1 до цільової суми, використовуючи попередні результати. 
Це гарантує мінімальну кількість монет для кожної суми.

### Порівняння ефективності:

#### Жадібний алгоритм:
- **Часова складність**: O(n), де n — кількість різних номіналів монет.
- **Продуктивність**: Жадібний алгоритм працює швидко і є оптимальним у більшості випадків, 
але не завжди дає мінімальну кількість монет для неідеальних наборів номіналів.
- **Перевага**: Простий і швидкий у виконанні, особливо для великих сум.

#### Алгоритм динамічного програмування:
- **Часова складність**: O(m * n), де m — цільова сума, а n — кількість різних номіналів монет.
- **Продуктивність**: Гарантує мінімальну кількість монет для будь-якого набору номіналів. 
Він може бути повільнішим для великих сум через необхідність обчислення для кожної проміжної суми.
- **Перевага**: Гарантує мінімальну кількість монет, навіть для складних наборів номіналів.

### Висновок:
Жадібний алгоритм швидший і простіший у використанні для класичних наборів монет, 
таких як [50, 25, 10, 5, 2, 1], де він завжди повертає оптимальний результат. 
Однак, якщо набір монет не такий ідеальний, динамічне програмування гарантує оптимальне рішення, 
хоч і за рахунок більшого часу виконання.

